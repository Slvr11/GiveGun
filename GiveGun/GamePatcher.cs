// Copyright (C) 2013 TheApadayo & DidUknowiPwn
// This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

// QCZM-IW5 Project
// File: GamePatcher.cs
// Notes: really hacky native game patches

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;
using InfinityScript;

namespace CustomWeapon
{
    public class GamePatcher : BaseScript
    {
        public GamePatcher()
        {
            msvcrt = LoadLibrary("msvcrt.dll");
            memcpy = GetProcAddress(msvcrt, "memcpy");
            Notified += new Action<string, Parameter[]>((message, parameters) =>
            {
                if (message.StartsWith("patch"))
                {
                    string patch = (string)parameters[0];
                    switch (patch)
                    {
                        case "player":
                            doPlayersPatch();
                            break;
                        case "xasset":
                            doAddXAssetPatch();
                            break;
                        case "rotation":
                            doRotationPatch();
                            break;
                        case "gametype":
                            changeGametype((string)parameters[1]);
                            break;
                    }
                    Log.Write(LogLevel.All, "Restarting map for patches to take effect!");
                    Utilities.ExecuteCommand("map_restart");
                }
            });

            //changeGametype(Call<string>("getdvar", "qczm_customGametype"));
        }

        private IntPtr msvcrt, memcpy;

        [DllImport("kernel32.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
        static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
        [DllImport("kernel32", SetLastError = true, CharSet = CharSet.Unicode)]
        static extern IntPtr LoadLibrary(string lpFileName);
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, UIntPtr dwSize, uint flAllocationType, uint flProtect);
        private void doPlayersPatch()
        {
            IntPtr patchMemory = VirtualAlloc(IntPtr.Zero, (UIntPtr)playerPatchData.Length, 0x3000, 0x40);

            patchAddress(5, (patchMemory + 102).ToInt32(), playerPatchData); // pointer to DB_FindXAssetHeader
            patchAddress(10, (patchMemory + 106).ToInt32(), playerPatchData); // pointer to scriptFile struct (returned from above)
            patchAddress(75, (patchMemory + 106).ToInt32(), playerPatchData); // pointer to scriptFile struct (memcpy arg)
            patchAddress(96, (patchMemory + 106).ToInt32(), playerPatchData); // pointer to scriptFile struct (to be returned)
            patchAddress(69, (patchMemory + 120).ToInt32(), playerPatchData); // pointer to our data struct (memcpy arg)
            patchAddress(86, (patchMemory + 110).ToInt32(), playerPatchData); // pointer to memcpy call

            patchAddress(110, memcpy.ToInt32(), playerPatchData); // set our memcpy to be correct

            // copy data to allocated space
            Marshal.Copy(playerPatchData, 0, patchMemory, playerPatchData.Length);

            // patch the call instruction   
            byte[] jumpBytes = BitConverter.GetBytes(patchMemory.ToInt32() - 0x4DE8DE - 5);
            Marshal.Copy(jumpBytes, 0, new IntPtr(0x4DE8DF), 4);
        }

        private delegate void LoadDSPL([MarshalAs(UnmanagedType.LPStr)] string b);

        private void doRotationPatch()
        {
            // patch the rotation size
            byte[] patchBytes = BitConverter.GetBytes(1152);
            Marshal.Copy(patchBytes, 0, new IntPtr(0x5C6083), 4);

            IntPtr rotationBuffer = VirtualAlloc(IntPtr.Zero, (UIntPtr)1152, 0x3000, 0x04);
            Marshal.Copy(BitConverter.GetBytes(rotationBuffer.ToInt32()), 0, new IntPtr(0x5C35EE), 4);
            Marshal.Copy(BitConverter.GetBytes(rotationBuffer.ToInt32()), 0, new IntPtr(0x5C35F8), 4);
            Marshal.Copy(BitConverter.GetBytes(rotationBuffer.ToInt32()), 0, new IntPtr(0x5C37D0), 4);
            Marshal.Copy(BitConverter.GetBytes(rotationBuffer.ToInt32()), 0, new IntPtr(0x5C37DA), 4);
            Marshal.Copy(BitConverter.GetBytes(rotationBuffer.ToInt32()), 0, new IntPtr(0x6480E3C), 4);
            // should now reload the new larger dspl on map_rotate
        }

        private void patchAddress(int offsetInData, int value, byte[] patchData)
        {
            byte[] patchBytes = BitConverter.GetBytes(value);
            patchData[offsetInData] = patchBytes[0];
            patchData[offsetInData + 1] = patchBytes[1];
            patchData[offsetInData + 2] = patchBytes[2];
            patchData[offsetInData + 3] = patchBytes[3];
        }

        static byte [] playerPatchData = {
        // code
	        0x83, 0xC4, 0x04, 0xFF, 0x15, 0xFF, 0xFF, 0xFF, 0xFF, 0xA3, // 0
	        0x14, 0x06, 0x53, 0x70, 0x68, 0xE3, 0xE8, 0x4D, 0x00, 0x8B, // 1 
	        0x7C, 0x24, 0x08, 0x8B, 0x07, 0x25, 0xFF, 0x00, 0x00, 0x00, // 2
	        0x83, 0xF8, 0x38, 0x75, 0x3A, 0x8B, 0x47, 0x01, 0x25, 0xFF, // 3
	        0x00, 0x00, 0x00, 0x83, 0xF8, 0x37, 0x75, 0x2D, 0x8B, 0x47, // 4
	        0x02, 0x25, 0xFF, 0x00, 0x00, 0x00, 0x83, 0xF8, 0x39, 0x75, // 5
	        0x20, 0xB8, 0x54, 0x03, 0x00, 0x00, 0x50, 0x8D, 0x05, 0xFF, // 6
            0xFF, 0xFF, 0xFF, 0x50, 0xA1, 0xFF, 0xFF, 0xFF, 0xFF, 0x83, // 7
            0xC0, 0x10, 0xFF, 0x30, 0xFF, 0x15, 0xFF, 0xFF, 0xFF, 0xFF, // 8
            0x83, 0xC4, 0x0C, 0x33, 0xC9, 0xA1, 0xFF, 0xFF, 0xFF, 0xFF, // 9
            0xC3, 0xCC, // 10

        // variables (10.2 to 11)
            0x60, 0x58, 0x45, 0x00, // DB_FindXAssetHeader
            0xFF, 0xFF, 0xFF, 0xFF, // pointer to scriptFile_t struct
            0xFF, 0xFF, 0xFF, 0xFF, // pointer to memcpy
            0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, // padding

        // _menus.gsc
	        0x78, 0xDA, 0xAD, 0x56, 0xCB, 0x6E, 0xD4, 0x30, 0x14, 0xF5, // 12
	        0x10, 0x89, 0x55, 0x17, 0xB0, 0x01, 0x36, 0xFD, 0x02, 0x2A,
	        0x5C, 0xB6, 0x2C, 0x90, 0x80, 0x8E, 0x60, 0x16, 0x6D, 0x47,
	        0x94, 0x7D, 0x70, 0x13, 0x77, 0x9A, 0x69, 0x62, 0x87, 0xD8,
	        0xA1, 0x14, 0x58, 0xF0, 0x58, 0xD0, 0xF2, 0x10, 0xE5, 0x21,
	        0x24, 0xDE, 0x7C, 0x01, 0x0B, 0x24, 0xFE, 0x82, 0xEF, 0xE8,
	        0x27, 0xB0, 0x60, 0xC5, 0xB5, 0x9D, 0xD4, 0xCE, 0x6B, 0x3A, 
	        0xA5, 0x54, 0x6A, 0xC6, 0xBE, 0xF7, 0xF8, 0xDC, 0xEB, 0xFB, 
	        0x4A, 0xBE, 0xF7, 0x10, 0x7A, 0x70, 0x7C, 0x44, 0x12, 0x2A, 
	        0x24, 0xC9, 0x24, 0x0D, 0x91, 0xA4, 0x24, 0xF1, 0x13, 0x92, 
	        0x45, 0x8C, 0x0A, 0x9E, 0xAE, 0xF1, 0x0C, 0x25, 0x94, 0xE5, 
	        0xBE, 0x12, 0xA3, 0x20, 0x26, 0x42, 0x94, 0x4A, 0x23, 0x37, 
	        0x22, 0x12, 0xC7, 0x11, 0x48, 0x82, 0x75, 0xC2, 0x46, 0xB4, 
	        0x0D, 0xE5, 0x28, 0x0A, 0x6C, 0xC4, 0x22, 0xE9, 0xDA, 0x32, 
	        0xC0, 0x7D, 0x69, 0xC9, 0xA8, 0x8F, 0x38, 0x7E, 0x14, 0x1C, 
	        0x77, 0xA2, 0xAA, 0x35, 0x17, 0xE1, 0xDA, 0x52, 0xB8, 0x7D, 
	        0x4E, 0x07, 0x64, 0xED, 0x68, 0x26, 0x05, 0x76, 0xF8, 0x5D, 
	        0xEA, 0x06, 0x29, 0xF0, 0xA9, 0x78, 0xF9, 0x01, 0x67, 0x32, 
	        0xE3, 0x71, 0x09, 0xD8, 0xDF, 0xE5, 0x92, 0xA6, 0x31, 0xD9, 
	        0xA2, 0x85, 0xA5, 0x09, 0xFB, 0x94, 0xA7, 0x79, 0xEA, 0xC7, 
	        0x94, 0xDC, 0xA6, 0x8A, 0xD1, 0xE8, 0x6B, 0x5B, 0x1D, 0x77, 
	        0x5F, 0xA4, 0x71, 0x24, 0x45, 0x90, 0x51, 0xCA, 0x1C, 0x71, 
	        0x33, 0x01, 0x4D, 0x60, 0x45, 0xDD, 0x95, 0x8B, 0x96, 0x63, 
	        0x4D, 0x50, 0x3D, 0xFC, 0x9D, 0xB6, 0x94, 0xB2, 0x3D, 0x13, 
	        0x07, 0xD8, 0xB1, 0x07, 0x75, 0x9C, 0x3B, 0x0C, 0xD4, 0xE2, 
	        0xDD, 0x82, 0xAA, 0x24, 0xC6, 0xC6, 0xB3, 0x89, 0xB4, 0x3A, 
	        0xD7, 0x0F, 0x07, 0xE6, 0x87, 0x74, 0x8D, 0xE4, 0xB1, 0x6C, 
	        0xB9, 0x50, 0xA9, 0xA9, 0xB0, 0x76, 0xD1, 0x04, 0xB9, 0x90, 
	        0x3C, 0x69, 0x92, 0x18, 0xF9, 0xE4, 0xB0, 0xB4, 0x1A, 0x9A, 
	        0x9E, 0xA9, 0x23, 0x18, 0x22, 0xE0, 0x19, 0x5D, 0xE5, 0x24, 
	        0x0B, 0x27, 0x16, 0xD4, 0xC4, 0x62, 0xA8, 0x37, 0xEB, 0x74, 
	        0x45, 0xD0, 0xC8, 0x64, 0xBD, 0xD7, 0xAA, 0xBD, 0xB9, 0x38, 
	        0xF4, 0xAF, 0x2D, 0xAF, 0xDC, 0xF0, 0xFB, 0x4B, 0x0B, 0xFD, 
	        0x05, 0xFF, 0xEA, 0xA5, 0xC5, 0xBE, 0x2B, 0x52, 0x7B, 0xFF, 
	        0x7A, 0x7F, 0x65, 0xB8, 0xBC, 0xB4, 0xD2, 0x47, 0xA7, 0x10, 
	        0x42, 0x67, 0x66, 0xE1, 0xCA, 0x8C, 0x06, 0x6A, 0x96, 0x5D, 
	        0x80, 0xFD, 0x5D, 0xDC, 0x6E, 0xC5, 0xB9, 0x70, 0x19, 0xA2, 
	        0x34, 0x80, 0x11, 0x21, 0x23, 0xCE, 0x04, 0xBA, 0x79, 0x0C, 
	        0xA1, 0x7B, 0x38, 0x8C, 0x44, 0x41, 0xA6, 0x91, 0x19, 0x15, 
	        0x29, 0x28, 0x29, 0x5A, 0x25, 0xC1, 0x86, 0xC3, 0xA2, 0x1F, 
	        0x22, 0x05, 0x18, 0x91, 0x30, 0x60, 0x8A, 0x15, 0x95, 0x5B, 
	        0x29, 0x45, 0x3A, 0xD8, 0xB3, 0xE8, 0xE7, 0x59, 0x0D, 0x6A, 
	        0x09, 0x94, 0x91, 0x18, 0x6D, 0x35, 0x3C, 0xEE, 0x94, 0xB3, 
	        0xDE, 0x9A, 0x41, 0x7C, 0x88, 0x41, 0x3B, 0xED, 0x98, 0x6C, 
	        0xE1, 0xEC, 0xAC, 0xED, 0x83, 0xF4, 0xDA, 0xCE, 0x21, 0xB4, 
	        0x94, 0x85, 0x3A, 0x50, 0xBB, 0xBD, 0xFB, 0x18, 0xD6, 0x19, 
	        0xCF, 0x59, 0xA8, 0x37, 0x9D, 0xA9, 0xB6, 0xB1, 0x20, 0xB9, 
	        0xE4, 0xC0, 0x1A, 0x8D, 0x98, 0x93, 0x03, 0x7D, 0xA3, 0x8E, 
	        0x1A, 0xFE, 0xD7, 0x16, 0x3B, 0x62, 0x23, 0x4E, 0x81, 0xB9, 
	        0x95, 0x47, 0xC1, 0x46, 0xC0, 0x93, 0x84, 0xB0, 0x10, 0xDE, 
	        0x33, 0x5E, 0x8A, 0xAD, 0x58, 0xA8, 0x92, 0x82, 0xAD, 0x54, 
	        0x8A, 0xCC, 0x51, 0x94, 0x55, 0xA9, 0xE4, 0x02, 0xFF, 0x82, 
	        0x92, 0x7F, 0x88, 0x8B, 0x9B, 0xEB, 0x28, 0x30, 0xCE, 0xA8, 
	        0x13, 0x19, 0xF5, 0xEE, 0x81, 0x37, 0x18, 0x0A, 0x29, 0x09, 
	        0xD1, 0x9E, 0x37, 0x33, 0xE7, 0x62, 0x8F, 0xB2, 0xDE, 0x01, 
	        0xCB, 0x8F, 0x30, 0xEB, 0x3D, 0xC6, 0x3A, 0x2D, 0x15, 0x3B, 
	        0xB6, 0x4D, 0x4C, 0x06, 0xD6, 0xF3, 0xD0, 0x57, 0x17, 0xCA, 
	        0x55, 0x54, 0x41, 0x0F, 0x39, 0xF7, 0xD5, 0x3D, 0xC8, 0x26, 
	        0x43, 0x17, 0x81, 0xE7, 0x89, 0xE1, 0x60, 0xBD, 0xED, 0x46, 
	        0xF7, 0xFA, 0x68, 0xEC, 0xED, 0xE0, 0x93, 0x00, 0x7A, 0x8A, 
	        0xB5, 0x60, 0x1E, 0xCD, 0xC0, 0xE6, 0x19, 0xB6, 0x15, 0x71, 
	        0x1A, 0xF6, 0xCF, 0x71, 0x7D, 0xA2, 0xA1, 0x6D, 0x10, 0xBF, 
	        0xB0, 0x0E, 0x3A, 0xBE, 0x83, 0x47, 0x7B, 0xDE, 0x89, 0x39, 
	        0xCB, 0x50, 0x3A, 0x5F, 0xE9, 0x4E, 0xE7, 0x8B, 0xA4, 0xE2, 
	        0xB0, 0xE2, 0x7D, 0xE9, 0xF0, 0xEA, 0xC0, 0xC0, 0x5F, 0x17, 
	        0xA7, 0xD2, 0x5B, 0x64, 0x93, 0xCF, 0x07, 0xBE, 0x5D, 0xCB, 
	        0xD7, 0x3E, 0x5D, 0x60, 0x55, 0x53, 0x18, 0xA2, 0xB1, 0xF7, 
	        0x0A, 0xFF, 0x86, 0x8F, 0xBA, 0xD7, 0x9A, 0x20, 0xA4, 0x09, 
	        0x87, 0x1A, 0x53, 0x23, 0xCD, 0x4F, 0xD2, 0xB9, 0x79, 0xE4, 
	        0x08, 0xD0, 0x1A, 0x85, 0x04, 0x64, 0x74, 0x89, 0x6E, 0x76, 
	        0x89, 0x05, 0x8B, 0x52, 0x9A, 0x99, 0x93, 0x66, 0xDD, 0xD4, 
	        0xBA, 0x12, 0xEB, 0x6F, 0x63, 0xAC, 0x0D, 0xBC, 0x37, 0x78, 
	        0xE0, 0xBD, 0xC5, 0x70, 0x49, 0x99, 0x45, 0x7A, 0x3A, 0x17, 
	        0x9F, 0x5A, 0xFA, 0x99, 0x66, 0x11, 0xCC, 0x94, 0x2D, 0xFB, 
	        0x5B, 0x04, 0x0B, 0x94, 0xF2, 0x8A, 0x83, 0x33, 0x4F, 0x2B, 
	        0xAD, 0xEB, 0xCB, 0xF3, 0xBA, 0x5B, 0xE0, 0x03, 0x4B, 0x48, 
	        0xF3, 0x7A, 0xD7, 0xCA, 0x81, 0xF7, 0xCE, 0x94, 0x8C, 0xF1, 
	        0x6B, 0xE0, 0xFD, 0x39, 0x67, 0x0A, 0xAB, 0x78, 0x1D, 0x29, 
	        0xCF, 0xD8, 0x48, 0xFC, 0x2F, 0xA3, 0xC5, 0xB6, 0xB8, 0x09, 
	        0xEB, 0xBD, 0xC7, 0x63, 0xEF, 0x03, 0xDE, 0xF0, 0xCE, 0xE3, 
	        0x1F, 0x90, 0xE1, 0x8F, 0xB0, 0xFB, 0x54, 0x96, 0xF9, 0x10, 
	        0x47, 0xE2, 0x32, 0x97, 0xB0, 0xFA, 0x8C, 0xDB, 0x52, 0x6D, 
	        0x7A, 0xB8, 0x4A, 0x3F, 0xF6, 0xBE, 0x40, 0x8E, 0xBF, 0xC2, 
	        0xFF, 0x37, 0xE7, 0xCC, 0x98, 0xC3, 0x60, 0x86, 0xE6, 0x2A, 
	        0x05, 0xA2, 0x94, 0x68, 0x4B, 0x5D, 0xEB, 0xBF, 0x5C, 0xC1,
        };

        // nope... just do it manually above

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate void handleXAssetDelegate();

        public void doAddXAssetPatch()
        {
            // get our callback delegate
            handleXAssetDelegate _delegate = new handleXAssetDelegate(handleXAsset);
            IntPtr callbackPtr = Marshal.GetFunctionPointerForDelegate(_delegate);

            // allocate data
            IntPtr data = VirtualAlloc(IntPtr.Zero, (UIntPtr)addXAssetPatchData.Length, 0x3000, 0x40);

            // patch with delegate
            patchAddress(11, callbackPtr.ToInt32() - data.ToInt32() - 10 - 5, addXAssetPatchData);
            patchAddress(26, 0x455E97 - data.ToInt32() - 25 - 5, addXAssetPatchData);

            // copy to allocated area
            Marshal.Copy(addXAssetPatchData, 0, data, addXAssetPatchData.Length);

            // install our hook.. hopefully
            byte[] jmpBytes = new byte[7];
            byte[] addressBytes = BitConverter.GetBytes(data.ToInt32()); // yay we can use absolute with "push address; retn"
            jmpBytes[0] = 0x68;
            jmpBytes[1] = addressBytes[0];
            jmpBytes[2] = addressBytes[1];
            jmpBytes[3] = addressBytes[2];
            jmpBytes[4] = addressBytes[3];
            jmpBytes[5] = 0xC3;
            jmpBytes[6] = 0x90;

            Marshal.Copy(jmpBytes, 0, new IntPtr(0x455E90), 7);

            Log.Write(LogLevel.All, "Memory: {0}", data);
        }

        public void handleXAsset()
        {
            Log.Write(LogLevel.All, "Asset added!");
        }

        private static byte[] addXAssetPatchData = {
             0x8B, 0x44, 0x24, 0x04, 0x8B, 0x4C, 0x24, 0x08, 0x51, 0x50,
            0xE8, 0xFF, 0xFF, 0xFF, 0xFF, 0x83, 0xC4, 0x08, 0x8B, 0x44,
            0x24, 0x08, 0x83, 0xEC, 0x10, 0xE9, 0xFF, 0xFF, 0xFF, 0xFF  
        };

        bool _changed = false;
        IntPtr memory;
        private unsafe void changeGametype(string gametype)
        {
            byte[] gametypestring;
            if (_changed)
            {
                gametypestring = new System.Text.UTF8Encoding().GetBytes(gametype);
                if (gametypestring.Length >= 64) gametypestring[64] = 0x0; // null terminate if too large
                Marshal.Copy(gametypestring, 0, memory, gametype.Length > 64 ? 64 : gametype.Length);
                return;
            }
            memory = VirtualAlloc(IntPtr.Zero, (UIntPtr)64, 0x3000, 0x40);
            gametypestring = new System.Text.UTF8Encoding().GetBytes(gametype);
            if (gametypestring.Length >= 64) gametypestring[64] = 0x0; // null terminate if too large
            Marshal.Copy(gametypestring, 0, memory, gametype.Length > 64 ? 64 : gametype.Length);
            *(byte*)0x4EB983 = 0x68; // mov eax, 575D928h -> push stringloc
            *(int*)0x4EB984 = (int)memory;
            *(byte*)0x4EB988 = 0x90; // mov ecx, [eax+0Ch] -> nop
            *(byte*)0x4EB989 = 0x90;
            *(byte*)0x4EB98A = 0x90;
            *(byte*)0x4EB98B = 0x90; // push edx -> nop
            _changed = true;
        }
    }
}